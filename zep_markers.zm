/******************************************************************************\
FILE:           zep_markers.zm
AUTHOR:         Chris van Run <C.P.A.vanrun@uu.nl>
GITHUB:         https://github.com/UiL-OTS-labs/ZEP-Markers-Module
ADAPTED BY:     -

DESCRIPTION:

This Zep module provides a way to send markers (i.e. triggers) from your Zep
experiment to a parallel input port. One such input port is the USB receiver
of the BioSemi EEG equipment. This allows you to send markers with Zep!

When comparing this module with sending markers from Presentation we found that
this module is slightly MORE reliable than the Presentation (c) software. Zep
sends markers with LESS variation in timing. Please see the comparison_test folder
in the repository for details about the test.

ATTENTION:
For USAGE instruction or more information read the README.md or visit the github
link above.

HISTORY:
2017-06-12 CvR Adjusted and tested with BioSemi equipment.
2017-06-15 CvR Added develop mode.
2017-06-26 CvR Rewrite and refactor for zep 2.0

\******************************************************************************/

plugin zep_iobeexybox;
plugin zep_math;
plugin zep_file;

// Set this mode if you need to develop or debug without having a BeexyBox
// The module will use an internal dummy transfer and make prints instead
// of outputting triggers.
//!! DO NOT FORGET TO DISABLE THIS WHEN RUNNING THE EXPERIMENT !!
const bool DEVELOP_MODE = false;

// If set to "" the module will let the BeexyBox object decide the Beexybox.
// If multiple are connected this might result in the wrong Beexybox being open
// To counteract you can set the serial of the device here:
const string DEVICE_SERIAL = "";

// This is the target device type that is expected to be found.
// most of the times this should be set to specify the X type.
const BeexyBoxType TARGET_DEVICE_TYPE = BXY_DEVICE_TYPE_X;

// The number of input / trigger lines at the receiving end define the minimum
// and maximum integer the device can send.
// For the BioSemi equipment this number of lines are 8.
// Hence we it only makes sense to output on 8 out of the 10 output lines that
// are available on the BeexyBox X.
const int NUMBER_OF_OUTPUT_LINES_DEVICE = 8;

// Length that the marker needs to be active in order to be registered
// default: 10ms
const dur PULSE_LENGTH = 10ms;

// The markers are buffered before they are sent to the marker device.
// The marker is transferred from the buffer to the device SCHEDULER_PRE_EMPT ms
// before the marker' onset.
const dur SCHEDULER_PRE_EMPT = 5ms;
const dur SCHEDULER_PRE_EMPT_ERROR_TOLERANCE = SCHEDULER_PRE_EMPT/2;

// Markers are logged in the following directory
const string LOG_FILE_DIRECTORY = "marker-logs";

// Sends the marker at a specified time with an optional pulse length.
// Returns true at successful setup
bool setup_marker_at(int number, time onset, dur pulse_length = PULSE_LENGTH)
{
    Marker new_marker;
    new_marker.number       = number;
    new_marker.onset        = onset;
    new_marker.pulse_length = pulse_length;
    if (!scheduler.add(new_marker)) return false;

    return true;
}

// Sends the marker as quickly as possible
// Returns true at successful setup
bool send_marker(int number, dur pulse_length = PULSE_LENGTH)
{
    return setup_marker_at(
            number,
            now() + SCHEDULER_PRE_EMPT + SCHEDULER_PRE_EMPT_ERROR_TOLERANCE,
            pulse_length
            );
}

// Record to hold Marker information ( for internal module usage )
record Marker
{
    int number;
    time onset;
    dur pulse_length;
}

// Container and communication interface for the BeexyBox X
BeexyBox marker_device
{
    // members
    int mask_bit_size;
    int max_number;
    int log_file_number;
    time init_time;

    on_event:init()
    {
        setup();
        if(error()) terminate;
    }

    void setup()
    {
        // warn if in development mode
        if(DEVELOP_MODE)
            print_error("!! WARNING - "
                    "Marker module is in develop mode, does not require a box"
                    " but will print and NOT output markers !!\n"
                    );

        // lets start up the party
        start_device();
        if(error()) return;

        // init some variables
        mask_bit_size   = NUMBER_OF_OUTPUT_LINES_DEVICE;
        this.set_log_file_number(0);
        max_number      = int(exp(2,mask_bit_size))-1;
        init_time       = now();

        // Start the log file.
        setup_log();
    }

    /*
     * To avoid collisions with other logging devices allow the
     * to set the log_file_number manually.
     *
     * Could be done directly on marker_device, but via function is
     * prettier.
     */
    void set_log_file_number(int number)
    {
        log_file_number = number;
    }

    // Opens up the connection to the BeexyBox device
    void start_device(string device_serial = DEVICE_SERIAL, BeexyBoxType device_type = TARGET_DEVICE_TYPE)
    {
        // Develop mode works without using an actual BeexyBox
        if(DEVELOP_MODE) return;

        if(device_serial != "")
            this.open(device_type, device_serial);
        else
            this.open(device_type);

        if(!this.is_open)
        {
            if(device_serial == "")
                print_error("!! ERROR - "
                        + "Marker module was unable to open" + cast<BeexyBoxType>(device_type) + " device !!\n"
                        );
            else
                print_error("!! ERROR - "
                        + "Marker module was unable to open " + cast<BeexyBoxType>(device_type) + " "
                        + device_serial
                        + " !!\n"
                        );
        }
    }

    /*
    * Tranfers the marker to the device
    *
    * Uses a bit wise operation:
    * For example for marker 3 (int) or 000000011 (byte)
    * it left shifts 1 (int) output_line times and does an AND operation
    * over both this shifted and the marker byte. For output_line 1:
    * 000000011 (marker byte)
    * 000000010 (left-shifted line)
    * 000000010 <= NOT 0 so true; we need to set this output line.
     */
    void transfer_marker(Marker mark)
    {
        int output_line = 0;
        while(output_line < this.mask_bit_size)
        {
            if(mark.number & (1 << output_line))
                this.start_output(output_line, mark.onset, mark.pulse_length);
            output_line++;
        }
    }

    // Initialises transfer and logging of marker.
    void mark(Marker mark)
    {
        // TRANSFER it
        if(DEVELOP_MODE)
            println(
                "[DEVELOP_MODE] Simulate marker " + mark.number + " transfer:\n"
                + "transfer time:\t"
                + format_wt(now(), TIME_FORMAT_TIME_HHMMSS_MICROS) + "\n"
                + "planned onset:\t"
                + format_wt(mark.onset, TIME_FORMAT_TIME_HHMMSS_MICROS)
            );
        else
            this.transfer_marker(mark);

        // LOG it
        this.log_marker(mark, true, "transferred");
    }

    bool setup_log()
    {
        string header = "date;target_timing(ms);marker;status\r\n";
        //Ensure existence
        if(!file_exists(LOG_FILE_DIRECTORY))
            create_dir(LOG_FILE_DIRECTORY);

        //Check access
        if(
            file_type(LOG_FILE_DIRECTORY) != FILE_TYPE_DIRECTORY ||
            !file_writable(LOG_FILE_DIRECTORY)
        )
        {
            print_error("!! Warning - Could not open log directory !!");
            return false;
        }

        open_log(log_file_number,
                    LOG_FILE_DIRECTORY + "/" +
                    format_wt(
                        now(),
                        TIME_FORMAT_DATE_YYYYMMDD + TIME_FORMAT_TIME_HHMM
                    ) +
                    "-" + log_file_number + ".log"
                    );
        log(log_file_number, "## Zero time: " + format_wt(init_time) + "\r\n");
        log(log_file_number, header);

        return true;
    }

    // Logs the marker with a status call
    void log_marker(Marker mark, bool success, string status)
    {
        dur target_time = mark.onset - init_time;

        //date;target_timing(ms);marker;status
        string delimiter = ";";
        string line =
            format_wt(now()) + delimiter
            + string(real(target_time)) + delimiter
            + mark.number + delimiter
            + string(success) + delimiter
            +  status + "\r\n";

        log(this.log_file_number, line);
    }

    on_event:cleanup()
    {
        // Log-related closures
        flush_log(log_file_number);
        close_log(log_file_number);

        // Close the connection to the device
        this.close();
    }
}

// Scheduler that connects to related functions
Timer scheduler {
    // Members
    Marker[..] scheduled_markers; // The wonders of arrays.
    Marker transferred_marker;

    on_event:init()
    {
        scheduled_markers.size      = 0;
        scheduled_markers.capacity  = 5;
    }

    on_event:expire()
    {
        Marker next_in_line = this.pop();

        // Check overloading conditions and final timing issues
        dur timing_off_set = now() - expire_time;
        if(timing_off_set > SCHEDULER_PRE_EMPT_ERROR_TOLERANCE)
        {
            print_error("!! ERROR Overloading - Marker " + next_in_line.number
                        +" failed to be pre-empted on time ("
                        + string(timing_off_set) +
                        " too late) !!\n"
                        );
            print_error("!! ERROR - Marker "
                        + next_in_line.number
                        + " dropped !!\n"
                        );
            marker_device.log_marker(next_in_line, false, "scheduling");
        }
        else
        {
            // all is well so transfer the marker to device
            marker_device.mark(next_in_line);
            this.transferred_marker = next_in_line;
        }
        reschedule();
    }

    // Starts to (re)schedule the pre-empt loading of markers
    void reschedule()
    {
        // Just stop if we ran out of markers
        if(scheduled_markers.size == 0) return;

        Marker next_in_line = scheduled_markers[scheduled_markers.size-1];
        time next_in_line_scheduler_onset =
                next_in_line.onset - SCHEDULER_PRE_EMPT;

        // We do not abort or change if the next in line marker timing hasn't changed.
        if(next_in_line_scheduler_onset == scheduler.expire_time &&
            scheduler.is_running
            )
            return;

        time current_time = now();
        // we are too late! Oh noes!
        if(next_in_line_scheduler_onset <= current_time)
        {
            print_error("!! ERROR Overloading - Marker "
                    + next_in_line.number
                    + " failed to be scheduled to pre-empt on time ("
                    + string(current_time-next_in_line_scheduler_onset)
                    + " too late) !!\n"
                    );
            pop(); // drop the next marker
            print_error("!! ERROR - Marker "
                    + next_in_line.number
                    + " dropped !!\n"
                    );
            reschedule(); // restart (re)scheduling the next marker in line
            marker_device.log_marker(next_in_line, false, "scheduling");
        }
        else
        {
            scheduler.abort();
            scheduler.start(next_in_line_scheduler_onset);
        }
    }

    // Adds marker
    bool add(Marker mark)
    {
        if(!valid_marker(mark))
        {
            marker_device.log_marker(mark, false, "validation");
            return false;
        }

        insert_marker(mark);

        // make sure the scheduler is doing it's job
        reschedule();

        return true;
    }

    // Returns the next in line marker and removes it from the stack
    Marker pop()
    {
        Marker popped = scheduled_markers[scheduled_markers.size-1];
        scheduled_markers.size = scheduled_markers.size-1;
        return popped;
    }

    // Checks the validity of the marker
    // Returns true if the marker is valid
    bool valid_marker(Marker mark)
    {
        if(!valid_attributes(mark)) return false;
        if(!valid_timing(mark)) return false;
        return true;
    }

    // A marker is valid if the number and pulse_length are reasonable
    bool valid_attributes(Marker mark)
    {
        // check number range
        if(mark.number < 1 || mark.number > marker_device.max_number )
        {
            print_error("!! WARNING - Marker "
                    + string(mark.number)
                    + " is outside of range (1-255) !!\n"
                    );
            return false;
        }

        // check pulse length
        if(mark.pulse_length <= 0ms )
        {
            print_error("!! WARNING - Marker "
                    + string(mark.number)
                    + "'s pulse length is set to 0 or below ("
                    + string(mark.pulse_length)
                    + "), this doesn't make any sense !!\n"
                    );
            return false;
        }
        return true;
    }

    /*
    * Checks the timing to see if there are no conflicts with buffered or scheduled markers
    * It does so more efficiently by assuming the stack buffer is ordered
    */
    bool valid_timing(Marker candidate_mark)
    {
        time candidate_scheduler_onset = candidate_mark.onset - SCHEDULER_PRE_EMPT;
        time candidate_offset = candidate_mark.onset + candidate_mark.pulse_length;

        // Check against the transered marker (the one currently loaded into the device)
        time transferred_offset =
                transferred_marker.onset + transferred_marker.pulse_length;

        if( transferred_offset >= candidate_scheduler_onset )
        {
            print_error("!! WARNING - Marker "
                    + string(candidate_mark.number)
                    + "'s onset conflicts with a marker ("
                    + transferred_marker.number
                    + ") that has already been pre-empteed to the device !!\n"
                    );
            return false;
        }

        int index = 0;
        while(index < scheduled_markers.size)
        {

            time scheduled_scheduler_onset =
                    scheduled_markers[index].onset - SCHEDULER_PRE_EMPT;
            time scheduled_offset =
                    scheduled_markers[index].onset +
                    scheduled_markers[index].pulse_length;

            if(overlap(scheduled_scheduler_onset,
                        scheduled_offset,
                        candidate_scheduler_onset,
                        candidate_offset
                        )
                )
            {
                print_error("!! WARNING - Marker "
                        + string(candidate_mark.number)
                        + "'s onset conflicts with a marker ("
                        + scheduled_markers[index].number
                        + ") that has already been scheduled !!\n"
                        );

                return false;
            }

            index++;
        }

        return true;
    }

    // insert a marker to the scheduled_markers
    void insert_marker(Marker mark)
    {
        // add marker to the top of the stack
        scheduled_markers.size = scheduled_markers.size+1;
        scheduled_markers[scheduled_markers.size-1] = mark;

        // Move the inserted item into position.
        int index = scheduled_markers.size - 1;
        Marker current_mark;
        Marker lower_mark;
        while(index >= 1)
        {
            current_mark = scheduled_markers[index];
            lower_mark = scheduled_markers[index - 1];
            if(current_mark.onset > lower_mark.onset) // first come first serve
                scheduled_markers.swap(index, index - 1);
            else
                // We can stop because we operate at the assumption
                // the stack is already in order
                return;
            index--;
        }
    }

    /*
    * Utility function
    * Returns true if the pulses set by that onset and offset and this onset
    * and offset overlap.
    */
    bool overlap(time that_onset, time that_offset, time this_onset, time this_offset)
    {
        return that_offset >= this_onset && this_offset >= that_onset;
    }

    // Prints the schedule for an overview of currently planned triggers
    void dump_schedule()
    {
        println("---");
        println("Overview of scheduled markers at "
                + format_wt(now(),
                TIME_FORMAT_TIME_HHMMSS_MICROS) +
                ":"
                );
        println("index\tmarker\tonset(hh:mm:ss...)\tpulse_length");
        int index = scheduled_markers.size-1;
        while(index >= 0)
        {
            Marker m = scheduled_markers[index];
            println(
                    string(index)
                    + ": \t" + string(m.number)
                    + "\t" + format_wt(m.onset, TIME_FORMAT_TIME_HHMMSS_MICROS)
                    + "\t\t" + m.pulse_length
                    );
            index--;
        }
        println("...");
    }
}
