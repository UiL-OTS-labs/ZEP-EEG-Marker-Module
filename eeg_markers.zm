/******************************************************************************\
FILE:           eeg_markers.zm
AUTHOR:         Chris van Run <C.P.A.vanrun@uu.nl>
GITHUB:         https://github.com/UiL-OTS-labs/ZEP-EEG-Marker-Module
ADAPTED BY:     -

DESCRIPTION:

This Zep module provides a way to send markers (i.e. triggers) from your Zep
experiment to a parallel input port. One such input port is the USB receiver
of the BioSemi EEG equipment. This allows you to send markers with Zep!

When comparing this module with sending markers from Presentation we found that
this module is slightly MORE reliable than the Presentation (c) software. Zep
sends markers with LESS variation in timing.

ATTENTION:
For USAGE instruction or more information read the README.md or visit the github
link above.

HISTORY:
2016-06-08 CvR Created and tested with BioSemi equipment.

\******************************************************************************/

plugin zep_digio;
plugin zep_misc;
plugin zep_math;
plugin zep_file;


// If set to "" the module will attempt to open the device at logical places
// If it can't find it, try /dev/ttyACM0
// default: ""
const string DEVICE_ADDRESS = "";
// const string DEVICE_ADDRESS = "/dev/ttyACM0";
// const string DEVICE_ADDRESS = "COM1";

// Length that the marker needs to be active in order to be registered
// default: 20ms
const dur PULSE_LENGTH = 20ms;

// The markers are buffered before they are sent to the marker device.
// The marker is transferred from the buffer to the device SCHEDULER_PRE_EMPT ms
// before the marker' onset.
const dur SCHEDULER_PRE_EMPT = 5ms;
const dur SCHEDULER_PRE_EMPT_ERROR_TOLERANCE = SCHEDULER_PRE_EMPT/2;

// Markers are logged in the following directory
const string LOG_FILE_DIRECTORY = "marker-logs";

// Sends the marker at a specified time with an optional pulse length.
// Returns true at successful setup
bool setup_marker_at(int number, time onset, dur pulse_length = PULSE_LENGTH)
{
    Marker new_marker;
    new_marker.number       = number;
    new_marker.onset        = onset;
    new_marker.pulse_length = pulse_length;
    if (!scheduler.add(new_marker)) return false;

    return true;
}

// Sends the marker as quickly as possible
// Returns true at successful setup
bool send_marker(int number, dur pulse_length = PULSE_LENGTH)
{
    return setup_marker_at(
            number,
            now() + SCHEDULER_PRE_EMPT + SCHEDULER_PRE_EMPT_ERROR_TOLERANCE,
            pulse_length
            );
}

// Record to hold Marker information ( for internal module usage )
record Marker
{
    int number;
    time onset;
    dur pulse_length;
}

// Container and communication interface for the BeexyBox X
BeexyBox marker_device
{
    // members
    int mask_bit_size;
    int max_number;
    int log_file_number;
    time init_time;

    on_event:init()
    {
        // lets start up the party
        if(!start_device()) terminate;

        // init some variables
        mask_bit_size = 8; // we only have 8 outputs to work with
        log_file_number = 0;
        max_number = int(exp(2,mask_bit_size))-1;
        init_time = now();
    }

    /*
     * To avoid collisions with other logging devices allow the
     * to set the log_file_number manually.
     *
     * Could be done directly on marker_device, but via function is
     * prettier. 
     */
    void set_log_file_number(int number)
    {
        log_file_number = number;
    }

    // Opens up the connection to the BeexyBox device
    bool start_device(string device_address = DEVICE_ADDRESS)
    {
        if(device_address != "")
            this.open(device_address);
        else
            this.open();

        if(!this.is_open)
        {
            if(device_address == "")
                print_error("!! ERROR - "
                        "Marker module was unable to open BeexyBox device !!\n"
                        );
            else
                print_error("!! ERROR - "
                        "Marker module was unable to open BeexyBox device at "
                        + DEVICE_ADDRESS
                        + " !!\n"
                        );
            return false;
        }
        
        // Start the log file.
        setup_log();

        return true;
    }

    // Sends the marker
    //
    // Uses a bit wise operation:
    // For example for marker 3 (int) or 000000011 (byte)
    // it left shifts 1 (int) output_line times and does an AND operation
    // over both this shifted and the marker byte. For output_line 1:
    // 000000011 (marker byte)
    // 000000010 (left-shifted line)
    // 000000010 <= NOT 0 so true; we need to set this output line.
    void transfer_marker(Marker mark)
    {
        int output_line = 0;
        while(output_line < this.mask_bit_size)
        {
            if(mark.number & (1 << output_line))
                this.start_output(output_line, mark.onset, mark.pulse_length);
            output_line++;
        }

        this.log_marker(mark, true, "transferred");
    }

    bool setup_log()
    {
        string header = "date;target_timing(ms);marker;status\r\n";
        //Ensure existence
        if(!file_exists(LOG_FILE_DIRECTORY))
            create_dir(LOG_FILE_DIRECTORY);

        //Check access
        if(
            file_type(LOG_FILE_DIRECTORY) != FILE_TYPE_DIRECTORY ||
            !file_writable(LOG_FILE_DIRECTORY)
        )
        {
            print_error("!! Warning - Could not open log directory !!");
            return false;
        }

        open_log(log_file_number,
                    LOG_FILE_DIRECTORY + "/" +
                    format_wt(
                        now(),
                        TIME_FORMAT_DATE_YYYYMMDD + TIME_FORMAT_TIME_HHMM
                        ) +
                    "-" + log_file_number + ".log"
                    );
        log(log_file_number, "## Zero time: " + format_wt(init_time) + "\r\n");
        log(log_file_number, header);

        return true;
    }

    // Logs the marker with a status call
    void log_marker(Marker mark, bool succes, string status)
    {
        dur target_time = mark.onset - init_time;

        //date;target_timing(ms);marker;status
        string delimiter = ";";
        string line =
            format_wt(now()) + delimiter
            + string(real(target_time)) + delimiter
            + mark.number + delimiter
            + string(succes) + delimiter
            +  status + "\r\n";

        log(this.log_file_number, line);
    }

    on_event:cleanup()
    {
        // Log-related closures
        flush_log(log_file_number);
        close_log(log_file_number);

        // Close the connection to the device
        this.close();
    }
}

// Scheduler that connects to related functions
Timer scheduler {
    // Members
    Marker[..] scheduled_markers; // The wonders of arrays.
    Marker transferred_marker;

    on_event:init()
    {
        scheduled_markers.size      = 0;
        scheduled_markers.capacity  = 5;
    }

    on_event:expire()
    {
        Marker next_in_line = this.pop();

        // Check overloading conditions and final timing issues
        dur timing_off_set = now() - expire_time;
        if(timing_off_set > SCHEDULER_PRE_EMPT_ERROR_TOLERANCE)
        {
            print_error("!! ERROR Overloading - Marker " + next_in_line.number
                        +" failed to be pre-empted on time ("
                        + string(timing_off_set) +
                        " too late) !!\n"
                        );
            print_error("!! ERROR - Marker "
                        + next_in_line.number
                        + " dropped !!\n"
                        );
            marker_device.log_marker(next_in_line, false, "scheduling");
        }
        else
        {
            // all is well so transfer the marker to device
            marker_device.transfer_marker(next_in_line);
            this.transferred_marker = next_in_line;
        }
        reschedule();
    }

    // Starts to (re)schedule the pre-empt loading of markers
    void reschedule()
    {
        // Just stop if we ran out of markers
        if(scheduled_markers.size == 0) return;

        Marker next_in_line = scheduled_markers[scheduled_markers.size-1];
        time next_in_line_scheduler_onset =
                next_in_line.onset - SCHEDULER_PRE_EMPT;

        // We do not abort or change if the next in line marker timing hasn't changed.
        if(next_in_line_scheduler_onset == scheduler.expected_expire_time &&
            scheduler.is_running
            )
            return;

        time current_time = now();
        // we are too late! Oh noes!
        if(next_in_line_scheduler_onset <= current_time) 
        {
            print_error("!! ERROR Overloading - Marker "
                    + next_in_line.number 
                    + " failed to be scheduled to pre-empt on time ("
                    + string(current_time-next_in_line_scheduler_onset)
                    + " too late) !!\n"
                    );
            pop(); // drop the next marker
            print_error("!! ERROR - Marker "
                    + next_in_line.number
                    + " dropped !!\n"
                    );
            reschedule(); // restart (re)scheduling the next marker in line
            marker_device.log_marker(next_in_line, false, "scheduling");
        }
        else
        {
            scheduler.abort();
            scheduler.start(next_in_line_scheduler_onset);
        }
    }

    // Adds marker
    bool add(Marker mark)
    {
        if(!valid_marker(mark))
        {
            marker_device.log_marker(mark, false, "validation");
            return false;
        }

        insert_marker(mark);

        // make sure the scheduler is doing it's job
        reschedule();

        return true;
    }

    // Returns the next in line marker and removes it from the stack
    Marker pop()
    {
        Marker popped = scheduled_markers[scheduled_markers.size-1];
        scheduled_markers.size = scheduled_markers.size-1;
        return popped;
    }

    // Checks the validity of the marker
    // Returns true if the marker is valid
    bool valid_marker(Marker mark)
    {
        if(!valid_attributes(mark)) return false;
        if(!valid_timing(mark)) return false;
        return true;
    }

    // A marker is valid if the number and pulse_length are reasonable
    bool valid_attributes(Marker mark)
    {
        // check number range
        if(mark.number < 1 || mark.number > marker_device.max_number )
        {
            print_error("!! WARNING - Marker "
                    + string(mark.number)
                    + " is outside of range (1-255) !!\n"
                    );
            return false;
        }

        // check pulse length
        if(mark.pulse_length <= 0ms )
        {
            print_error("!! WARNING - Marker "
                    + string(mark.number)
                    + "'s pulse length is set to 0 or below ("
                    + string(mark.pulse_length)
                    + "), this doesn't make any sense !!\n"
                    );
            return false;
        }
        return true;
    }

    // Checks the timing to see if there are no conflicts with buffered or scheduled markers
    // It does so more efficiently by assuming the stack buffer is ordered
    bool valid_timing(Marker candidate_mark)
    {
        time candidate_scheduler_onset = candidate_mark.onset - SCHEDULER_PRE_EMPT;
        time candidate_offset = candidate_mark.onset + candidate_mark.pulse_length;

        // Check against the transered marker (the one currently loaded into the device)
        time transferred_offset =
                transferred_marker.onset + transferred_marker.pulse_length;

        if( transferred_offset >= candidate_scheduler_onset )
        {
            print_error("!! WARNING - Marker "
                    + string(candidate_mark.number)
                    + "'s onset conflicts with a marker ("
                    + transferred_marker.number
                    + ") that has already been pre-empteed to the device !!\n"
                    );
            return false;
        }

        int index = 0;
        while(index < scheduled_markers.size)
        {

            time scheduled_scheduler_onset =
                    scheduled_markers[index].onset - SCHEDULER_PRE_EMPT;
            time scheduled_offset =
                    scheduled_markers[index].onset +
                    scheduled_markers[index].pulse_length;

            if(overlap(scheduled_scheduler_onset,
                        scheduled_offset,
                        candidate_scheduler_onset,
                        candidate_offset
                        )
                )
            {
                print_error("!! WARNING - Marker "
                        + string(candidate_mark.number)
                        + "'s onset conflicts with a marker ("
                        + scheduled_markers[index].number
                        + ") that has already been scheduled !!\n"
                        );

                return false;
            }

            index++;
        }

        return true;
    }

    // insert a marker to the scheduled_markers
    void insert_marker(Marker mark)
    {
        // add marker to the top of the stack
        scheduled_markers.size = scheduled_markers.size+1;
        scheduled_markers[scheduled_markers.size-1] = mark;

        // Move the inserted item into position.
        int index = scheduled_markers.size - 1;
        Marker current_mark;
        Marker lower_mark;
        while(index >= 1)
        {
            current_mark = scheduled_markers[index];
            lower_mark = scheduled_markers[index - 1];
            if(current_mark.onset > lower_mark.onset) // first come first serve
                scheduled_markers.swap(index, index - 1);
            else
                // We can stop because we operate at the assumption
                // the stack is already in order
                return;
            index--;
        }
    }

    // Returns true if the pulses set by that onset and offset and this onset
    // and offset overlap.
    bool overlap(time that_onset, time that_offset, time this_onset, time this_offset)
    {
        return that_offset >= this_onset && this_offset >= that_onset;
    }

    // Prints the schedule for an overview of currently planned triggers
    void dump_schedule()
    {
        println("---");
        println("Overview of scheduled markers at "
                + format_wt(now(),
                TIME_FORMAT_TIME_HHMMSS_MICROS) +
                ":"
                );
        println("index\tmarker\tonset(hh:mm:ss...)\tpulse_length");
        int index = scheduled_markers.size-1;
        while(index >= 0)
        {
            Marker m = scheduled_markers[index];
            println(
                    string(index)
                    + ": \t" + string(m.number)
                    + "\t" + format_wt(m.onset, TIME_FORMAT_TIME_HHMMSS_MICROS)
                    + "\t\t" + m.pulse_length
                    );
            index--;
        }
        println("...");
    }
}
